// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © atraderstoolbox

//@version=5
indicator("for_jiv789_v5", overlay = true, max_labels_count = 500, max_boxes_count = 500, max_lines_count = 500, max_bars_back = 2000)


// SETTINGS

// general settings
focus_mode      = input.bool(false, title = 'Focus Mode   ', group = 'Settings', inline = '1', 
 tooltip = 'Only show the most recent levels. A Value of 250 will only show structure that started 250 bars ago or less.')
focus_mode_len  = input.int(250, title = ' ', group = 'Settings', inline = '1', minval = 10, maxval = 5000)

indicator_zooming = input.int(30, title = 'Indicator Spacing', group = 'Settings', minval = 10, maxval = 100, step = 10,
 tooltip = 'Affects the location of items relative to the current bar number.')



// alert settings
_bullish_bos        = input.bool(true, title = 'Bullish BOS      ', group = 'Alerts', inline = '1')
_bullish_choch      = input.bool(true, title = 'Bullish CHoCH   ', group = 'Alerts', inline = '2')
_bullish_hh         = input.bool(true, title = 'Bullish HH      ', group = 'Alerts', inline = '3')
_bullish_hl         = input.bool(true, title = 'Bullish HL      ', group = 'Alerts', inline = '4')
_bullish_eql        = input.bool(true, title = 'Bullish EQL     ', group = 'Alerts', inline = '5')
_bullish_demand_zone= input.bool(true, title = 'Bullish New Demand Zone', group = 'Alerts', inline = '6')
_bullish_indz       = input.bool(true, title = 'Bullish Demand Zone', group = 'Alerts', inline = '7')

_bearish_bos        = input.bool(true, title = 'Bearish BOS', group = 'Alerts', inline = '1')
_bearish_choch      = input.bool(true, title = 'Bearish CHoCH', group = 'Alerts', inline = '2')
_bearish_ll         = input.bool(true, title = 'Bearish LL', group = 'Alerts', inline = '3')
_bearish_lh         = input.bool(true, title = 'Bearish LH', group = 'Alerts', inline = '4')
_bearish_eqh        = input.bool(true, title = 'Bearish EQH', group = 'Alerts', inline = '5')
_bearish_supply_zone= input.bool(true, title = 'Bearish New Supply Zone', group = 'Alerts', inline = '8')
_bearish_insz       = input.bool(true, title = 'Bearish In Supply Zone', group = 'Alerts', inline = '9')





// supply demand settings
use_sd          = input.bool(true, title = 'Supply & Demand Zones', group = 'Supply/Demand Settings', inline = '1')
swing_length    = input.int(10, title = 'Length        ', minval = 2, maxval = 50,  group = 'Supply/Demand Settings', inline = '2')

boxes_location  = input.string('On Candle', title = 'Zone Location ', options = ['On Candle', 'On Wick'],group = 'Supply/Demand Settings', inline = '3')
boxes_width     = input.float(7.5, title = 'Zone Width   ', minval = 1, maxval = 15, step = 0.5,  group = 'Supply/Demand Settings', inline = '4')
history_of_demand_to_keep = 50

_css_supply     = input.color(color.new(#434651,40), title = 'Supply ',  group = 'Supply/Demand Settings', inline = '5')
_css_textsupply = input.color(color.new(#000000,0), title = 'Text',  group = 'Supply/Demand Settings', inline = '5')
_css_supplyout   = input.color(color.new(color.white,0), title = 'Outline',  group = 'Supply/Demand Settings', inline = '5')
// _style_supply   = input.string('Solid', title = '', options = ['Solid', 'Dotted', 'Dashed'], group = 'Supply/Demand Settings', inline = '5')

_css_demand     = input.color(color.new(#434651,40), title = 'Demand',  group = 'Supply/Demand Settings', inline = '6')
_css_textdemand = input.color(color.new(#000000, 0), title = 'Text',  group = 'Supply/Demand Settings', inline = '6')
_css_demandout   = input.color(color.new(#11ffe7, 0), title = 'Outline',  group = 'Supply/Demand Settings', inline = '6')
// _style_demand   = input.string('Solid', title = '', options = ['Solid', 'Dotted', 'Dashed'], group = 'Supply/Demand Settings', inline = '6')

css_supply      = not use_sd ? color.new(#000000,100) : _css_supply
css_textsupply  = not use_sd ? color.new(#000000,100) : _css_textsupply
css_supplyout   = not use_sd ? color.new(#000000,100) : _css_supplyout
style_supply    = line.style_solid

css_demand      = not use_sd ? color.new(#000000,100) :_css_demand
css_textdemand  = not use_sd ? color.new(#000000,100) :_css_textdemand
css_demandout   = not use_sd ? color.new(#000000,100) : _css_demandout
style_demand    = line.style_solid 

use_volumemetrics = input.bool(true, title = 'Show Volume Metrics', group = 'Supply/Demand Settings', inline = '7')
_css_zonebuy    = input.color(color.rgb(0, 255, 8), title = 'Buy Volume',  group = 'Supply/Demand Settings', inline = '8')
_css_zonesell   = input.color(color.rgb(255, 0, 0), title = 'Sell Volume',  group = 'Supply/Demand Settings', inline = '8')







// bos settings
use_bos = input.bool(true, title = 'BOS', group = 'BOS Settings', inline = '1')

_css_bos        = input.color(color.new(#808080,40), title = 'Line',  group = 'BOS Settings', inline = '2')
_css_textbos    = input.color(color.new(#000000,40), title = 'Text',  group = 'BOS Settings', inline = '2')
_style_bos      = input.string('Solid', title = '', options = ['Solid', 'Dotted', 'Dashed'], group = 'BOS Settings', inline = '2')

css_bos         = not use_bos ? color.new(#000000,100) : _css_bos
css_textbos     = not use_bos ? color.new(#000000,100) : _css_textbos
style_bos       = _style_bos == 'Solid' ?  line.style_solid : _style_bos == 'Dotted' ? line.style_dotted : line.style_dashed



// choch settings
use_choch         = input.bool(true, title = 'CHoCH', group = 'CHoCH Settings', inline = '1')

_css_choch        = input.color(color.new(#808080,40), title = 'Line',  group = 'CHoCH Settings', inline = '2')
_css_textchoch    = input.color(color.new(#000000,40), title = 'Text',  group = 'CHoCH Settings', inline = '2')
_style_choch      = input.string('Solid', title = '', options = ['Solid', 'Dotted', 'Dashed'], group = 'CHoCH Settings', inline = '2')

css_choch         = not use_choch ? color.new(#000000,100) : _css_choch
css_textchoch     = not use_choch ? color.new(#000000,100) : _css_textchoch
style_choch       = _style_choch == 'Solid' ?  line.style_solid : _style_choch == 'Dotted' ? line.style_dotted : line.style_dashed



// eqh & eql settings
use_eqhl1           = input.bool(true, title = 'EQH & EQL 1', group = 'Equal High/Low Settings', inline = '1')
_eq_length1         = input.int(10, title = '', group = 'Equal High/Low Settings', inline = '1', minval = 1)
_eq_threshold1      = input.float(0.1, title = '', group = 'Equal High/Low Settings', inline = '1', minval = 0.05)

use_eqhl2           = input.bool(true, title = 'EQH & EQL 2', group = 'Equal High/Low Settings', inline = '2')
_eq_length2         = input.int(20, title = '', group = 'Equal High/Low Settings', inline = '2', minval = 1)
_eq_threshold2      = input.float(0.2, title = '', group = 'Equal High/Low Settings', inline = '2', minval = 0.05)

use_eqhl3           = input.bool(true, title = 'EQH & EQL 3', group = 'Equal High/Low Settings', inline = '3')
_eq_length3         = input.int(50, title = '', group = 'Equal High/Low Settings', inline = '3', minval = 1)
_eq_threshold3      = input.float(0.4, title = '', group = 'Equal High/Low Settings', inline = '3', minval = 0.05)

use_eqhl4           = input.bool(true, title = 'EQH & EQL 4', group = 'Equal High/Low Settings', inline = '4')
_eq_length4         = input.int(100, title = '', group = 'Equal High/Low Settings', inline = '4', minval = 1)
_eq_threshold4      = input.float(0.4, title = '', group = 'Equal High/Low Settings', inline = '4', minval = 0.05)

use_eqhl5           = input.bool(true, title = 'EQH & EQL 5', group = 'Equal High/Low Settings', inline = '5')
_eq_length5         = input.int(200, title = '', group = 'Equal High/Low Settings', inline = '5', minval = 1)
_eq_threshold5      = input.float(0.4, title = '', group = 'Equal High/Low Settings', inline = '5', minval = 0.05)

_css_eqh        = input.color(color.new(#e00000,0), title = 'EQH Line',  group = 'Equal High/Low Settings', inline = '6')
_css_texteqh    = input.color(color.new(#e00000,0), title = 'Text',  group = 'Equal High/Low Settings', inline = '6')
_style_eqh      = input.string('Solid', title = '', options = ['Solid', 'Dotted', 'Dashed'], group = 'Equal High/Low Settings', inline = '6')

css_eqh         =  _css_eqh
css_texteqh     = _css_texteqh
style_eqh       = _style_eqh == 'Solid' ?  line.style_solid : _style_eqh == 'Dotted' ? line.style_dotted : line.style_dashed

_css_eql        = input.color(color.new(#0ad13f,0), title = 'EQL Line',  group = 'Equal High/Low Settings', inline = '7')
_css_texteql    = input.color(color.new(#0ad13f,0), title = 'Text',  group = 'Equal High/Low Settings', inline = '7')
_style_eql      = input.string('Solid', title = '', options = ['Solid', 'Dotted', 'Dashed'], group = 'Equal High/Low Settings', inline = '7')

css_eql         = _css_eql
css_texteql     = _css_texteql
style_eql       = _style_eql == 'Solid' ?  line.style_solid : _style_eql == 'Dotted' ? line.style_dotted : line.style_dashed



// volume profile settings
use_vp          = input.bool(true, title = 'Volume Profile', group = 'Volume Profile Settings', inline = '1')
vp_color        = input.color(color.new(#434651,0), title = '', group = 'Volume Profile Settings', inline = '1')
vp_length       = input.int(500, title = 'VP Bar History', group = 'Volume Profile Settings', minval = 10, maxval = 3000, step = 100, tooltip = 'Number of bars back to calculate total volume histogram. (10-3000)')
vp_location     = input.int(70, title = 'VP Size', group = 'Volume Profile Settings', minval = 30, maxval = 150, step = 10, tooltip = '30-150')
vp_row          = input.int(200, title = '# of Rows', group = 'Volume Profile Settings', minval = 50, maxval = 200, step = 25, tooltip = '50-200')
bar_vp_width    = vp_row >= 150 ? 2 : vp_row >= 120 ? 4 : vp_row >= 100 ? 6 : vp_row >= 80 ? 8 : 10



// price action label settings
use_pa_labels = input.bool(false, title = 'Price-Action Labels', group = 'Price-Action Label Settings', inline = '1')

_css_pa_labels      = input.color(color.new(#808080,40), title = ' ',  group = 'Price-Action Label Settings', inline = '1')
css_pa_labels       = not use_pa_labels ?  color.new(#ffffff,100) : _css_pa_labels 







// FUNCTIONS


// FUNCTION TO ADD NEW AND REMOVE LAST IN ARRAY
f_array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)


// function to get swing h/l, previous swing h/l, and tell trend
f_get_swing_values(sd_length) =>
    sh = ta.pivothigh(high, sd_length, sd_length)
    sl = ta.pivotlow(low, sd_length, sd_length)

    csh = ta.valuewhen(ta.pivothigh(high, sd_length, sd_length), high[sd_length], 0)
    csl = ta.valuewhen(ta.pivotlow(low, sd_length, sd_length), low[sd_length], 0)

    psh = ta.valuewhen(ta.pivothigh(high, sd_length, sd_length), high[sd_length], 1)
    psl = ta.valuewhen(ta.pivotlow(low, sd_length, sd_length), low[sd_length], 1)

    hh = sh >= psh
    lh = sh < psh
    ll = sl <= psl
    hl = sl > psl

    var int trend = na
    trend := ((hh and high >= psh) or close > csh) ? 1 : ((ll and low <= psl) or close < csl) ? -1 : lh or hl ? 0 : trend[1]

    var int last_signal = na
    last_signal := hh ? 2 : lh ? -1 : ll ? -2 : hl ? 1 : last_signal[1]

    if use_pa_labels
        if sh
            label.new(time[swing_length], csh, text = hh ? 'HH' : 'LH', style=label.style_label_down, textcolor = css_pa_labels, color = color.new(css_pa_labels, 100), size = size.tiny, xloc = xloc.bar_time)
        if sl
            label.new(time[swing_length], csl, text = ll ? 'LL' : 'HL', style=label.style_label_up, textcolor = css_pa_labels, color = color.new(css_pa_labels, 100), size = size.tiny, xloc = xloc.bar_time)


    [sh, sl, psh, psl, csh, csl, hh, lh, ll, hl, trend, last_signal]




// FUNCTION MAKE SURE SUPPLY ISNT OVERLAPPING
f_check_overlapping(new_poi, box_array, atr) =>
    atr_threshold = atr * 2
    okay_to_draw = true

    for i = 0 to array.size(box_array) - 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        poi = (top + bottom) / 2

        upper_boundary = poi + atr_threshold
        lower_boundary = poi - atr_threshold

        if new_poi >= lower_boundary and new_poi <= upper_boundary
            okay_to_draw := false
            break
        else 
            okay_to_draw := true
    okay_to_draw



// FUNCTION FOR NEW ZONES TO CALCULATE VOLUME METRICS
f_volume_metricsnew(box_top, box_bottom) =>
    var float total_buyv = 0.00
    var float total_sellv = 0.00

    total_buyv  := 0
    total_sellv := 0

    for i = 1 to swing_length
        top_wick    = high[i] - math.max(close[i], open[i])
        bottom_wick = math.min(close[i], open[i]) - low[i]
        body_size   = math.abs(close[i]-open[i])  

        buy_v_calc  =  0.5 * (top_wick + bottom_wick + (open[i] <= close[i] ? 2 * body_size : 0)) / (top_wick + bottom_wick + body_size)
        sell_v_calc =  0.5 * (top_wick + bottom_wick + (open[i] > close[i] ? 2 * body_size : 0)) / (top_wick + bottom_wick + body_size)
        buy_v       = volume[i] * (nz(buy_v_calc) == 0 ? 0.5 : buy_v_calc)
        sell_v      = volume[i] * (nz(sell_v_calc) == 0 ? 0.5 : sell_v_calc)

        inside_zone = (high[i] >= box_top and low[i] <= box_top) or (high[i] >= box_bottom and low[i] <= box_bottom)

        if inside_zone
            total_buyv  += buy_v
            total_sellv += sell_v

    [math.round(total_buyv, 0), math.round(total_sellv,0)]









// FUNCTION TO DRAW SUPPLY OR DEMAND ZONE
f_supply_demand(box_array, label_array, boxbuy_array, boxsell_array, buyv_array, sellv_array, box_type, atr) =>
    atr_buffer = atr * (boxes_width / 10)
    box_left = time[swing_length]
    box_right = time

    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00
    var bool new_supply_or_demand = false

    if box_type == 1
        box_top := boxes_location == 'On Candle' ? math.max(close[swing_length], open[swing_length]) : high[swing_length]
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
    else if box_type == -1
        box_bottom := boxes_location == 'On Candle' ? math.min(close[swing_length], open[swing_length]) : low[swing_length]
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2

    okay_to_draw = f_check_overlapping(poi, box_array, atr)

    if okay_to_draw
        new_supply_or_demand := true
        [buyv, sellv] = f_volume_metricsnew(box_top, box_bottom)
        f_array_add_pop(buyv_array, buyv)
        f_array_add_pop(sellv_array, sellv)
        total_vol = buyv + sellv
        all_zone_vol = array.sum(buyv_array) + array.sum(sellv_array)
        vol_pct = total_vol / all_zone_vol *  100
        text_addition = str.tostring(total_vol, format.volume) + "  (" + str.tostring(vol_pct, format.percent) + ")"

        buy_right = math.floor(box_right + ((box_right-box_left) * (buyv / total_vol))) 
        sell_right = math.floor(box_right + ((box_right-box_left) * (sellv / total_vol)))
        box_mid = (box_top + box_bottom) / 2  


        //delete oldest box, and then create a new box and add it to the array
        if box_type == 1 
            if use_sd and use_volumemetrics
                box.delete( array.get(boxbuy_array, array.size(boxbuy_array) - 1) )
                f_array_add_pop(boxbuy_array, box.new( left = box_left, top = box_top, right = buy_right, bottom = box_mid, border_color = _css_zonebuy,
                 bgcolor = _css_zonebuy, extend = extend.none, text = "", text_halign = text.align_center, text_valign = text.align_center, 
                 text_color = css_textsupply, text_size = size.small, xloc = xloc.bar_time, border_style = style_supply))

                box.delete( array.get(boxsell_array, array.size(boxsell_array) - 1) )
                f_array_add_pop(boxsell_array, box.new( left = box_left, top = box_mid, right = sell_right, bottom = box_bottom, border_color = _css_zonesell,
                 bgcolor = _css_zonesell, extend = extend.none, text = "", text_halign = text.align_center, text_valign = text.align_center, 
                 text_color = css_textsupply, text_size = size.small, xloc = xloc.bar_time, border_style = style_supply))

            box.delete( array.get(box_array, array.size(box_array) - 1) )
            f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = css_supplyout, border_width = 1,
             bgcolor = css_supply, extend = extend.right, text = use_volumemetrics ? text_addition : "SUPPLY", text_halign = use_volumemetrics ? text.align_right : text.align_center, text_valign = text.align_center, 
             text_color = css_textsupply, text_size = size.small, xloc = xloc.bar_time, border_style = style_supply))

            box.delete( array.get(label_array, array.size(label_array) - 1) )
            f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.new(_css_supply,30),
             bgcolor = css_supply, extend = extend.right, text = '', text_halign = text.align_left, text_valign = text.align_center,
             text_color = css_textsupply, text_size = size.small, xloc = xloc.bar_time, border_style = line.style_dotted))
        
        else if box_type == -1
            if use_sd and use_volumemetrics
                box.delete( array.get(boxbuy_array, array.size(boxbuy_array) - 1) )
                f_array_add_pop(boxbuy_array, box.new( left = box_left, top = box_top, right = buy_right, bottom = box_mid, border_color = _css_zonebuy,
                 bgcolor = _css_zonebuy, extend = extend.none, text = "", text_halign = text.align_center, text_valign = text.align_center, 
                 text_color = css_textsupply, text_size = size.small, xloc = xloc.bar_time, border_style = style_demand))

                box.delete( array.get(boxsell_array, array.size(boxsell_array) - 1) )
                f_array_add_pop(boxsell_array, box.new( left = box_left, top = box_mid, right = sell_right, bottom = box_bottom, border_color = _css_zonesell,
                 bgcolor = _css_zonesell, extend = extend.none, text = "", text_halign = text.align_center, text_valign = text.align_center, 
                 text_color = css_textsupply, text_size = size.small, xloc = xloc.bar_time, border_style = style_demand))

            box.delete( array.get(box_array, array.size(box_array) - 1) )
            f_array_add_pop(box_array, box.new( left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = css_demandout, border_width = 1,
             bgcolor = css_demand, extend = extend.right,  text = use_volumemetrics ? text_addition : "DEMAND", text_halign = use_volumemetrics ? text.align_right : text.align_center, text_valign = text.align_center, 
             text_color = css_textdemand, text_size = size.small, xloc = xloc.bar_time, border_style = style_demand))

            box.delete( array.get(label_array, array.size(label_array) - 1) )
            f_array_add_pop(label_array, box.new( left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.new(_css_demand,30),
             bgcolor = css_demand, extend = extend.right,  text = '', text_halign = text.align_left, text_valign = text.align_center,
             text_color =  css_textdemand, text_size = size.small, xloc = xloc.bar_time, border_style = line.style_dotted))

    new_supply_or_demand

// FUNCTION TO CHANGE SUPPLY/DEMAND TO A BOS IF BROKEN
f_sd_to_bos_choch(box_array, label_array, box_barray, box_sarray, buyv_array, sellv_array, bos_array, choch_array, can_choch, zone_type) =>
    choch_count = 0
    bos_count = 0
    in_demand_zone = 0
    in_supply_zone = 0


    // supply
    if zone_type == 1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_top(array.get(box_array,i))
            box_top = box.get_top(array.get(box_array,i))
            box_bottom = box.get_bottom(array.get(box_array,i))

            if close >= level_to_break
                // choch supply
                if can_choch
                    if use_choch
                        copied_box = box.copy(array.get(box_array,i))
                        f_array_add_pop(choch_array, copied_box)
                        mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                        box.set_top(array.get(choch_array,0), mid)
                        box.set_bottom(array.get(choch_array,0), mid)
                        box.set_extend( array.get(choch_array,0), extend.none)
                        box.set_right( array.get(choch_array,0), time)
                        box.set_text( array.get(choch_array,0), 'CHoCH' )
                        box.set_text_valign( array.get(choch_array,0), text.align_top)
                        box.set_bgcolor( array.get(choch_array,0), css_choch)
                        box.set_border_color( array.get(choch_array,0), css_choch)
                        box.set_border_style(array.get(choch_array,0), style_choch)
                        box.set_text_color( array.get(choch_array,0), css_textchoch)
                        box.set_text_size( array.get(choch_array,0), size.small)
                        box.set_text_halign( array.get(choch_array,0), text.align_center)
                        box.set_text_valign( array.get(choch_array,0), text.align_center)
                    choch_count += 1
                else
                    //  bos supply
                    if use_bos
                        copied_box = box.copy(array.get(box_array,i))
                        f_array_add_pop(bos_array, copied_box)
                        mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                        box.set_top(array.get(bos_array,0), mid)
                        box.set_bottom(array.get(bos_array,0), mid)
                        box.set_extend( array.get(bos_array,0), extend.none)
                        box.set_right( array.get(bos_array,0), time)
                        box.set_text( array.get(bos_array,0), 'BOS' )
                        box.set_text_valign( array.get(bos_array,0), text.align_top)
                        box.set_bgcolor( array.get(bos_array,0), css_bos)
                        box.set_border_color( array.get(bos_array,0), css_bos)
                        box.set_border_style(array.get(bos_array,0), style_bos)
                        box.set_text_color( array.get(bos_array,0), css_textbos)
                        box.set_text_size( array.get(bos_array,0), size.small)
                        box.set_text_halign( array.get(bos_array,0), text.align_center)
                        box.set_text_valign( array.get(bos_array,0), text.align_center)
                    bos_count += 1
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))
                box.delete(array.get(box_barray, i))
                box.delete(array.get(box_sarray, i))
                array.set(buyv_array, i, 0.00) 
                array.set(sellv_array, i, 0.00) 
            else
                if (high >= box_top and low <= box_top) or (high >= box_bottom and low <= box_bottom)
                    in_supply_zone += 1

    // demand
    if zone_type == -1
        for i = 0 to array.size(box_array) - 1
            level_to_break = box.get_bottom(array.get(box_array,i))
            box_top = box.get_top(array.get(box_array,i))
            box_bottom = box.get_bottom(array.get(box_array,i))
            if close <= level_to_break
                // choch demand
                if can_choch
                    if use_choch 
                        copied_box = box.copy(array.get(box_array,i))
                        f_array_add_pop(choch_array, copied_box)
                        mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                        box.set_top(array.get(choch_array,0), mid)
                        box.set_bottom(array.get(choch_array,0), mid)
                        box.set_extend( array.get(choch_array,0), extend.none)
                        box.set_right( array.get(choch_array,0), time)
                        box.set_text( array.get(choch_array,0), 'CHoCH' )
                        box.set_text_valign( array.get(choch_array,0), text.align_bottom)
                        box.set_bgcolor( array.get(choch_array,0), css_choch)
                        box.set_border_color( array.get(choch_array,0), css_choch)
                        box.set_border_style(array.get(choch_array,0), style_choch)
                        box.set_text_color( array.get(choch_array,0), css_textchoch)
                        box.set_text_size( array.get(choch_array,0), size.small)
                        box.set_text_halign( array.get(choch_array,0), text.align_center)
                        box.set_text_valign( array.get(choch_array,0), text.align_center)
                    choch_count += 1
                else
                    // bos demand
                    if use_bos
                        copied_box = box.copy(array.get(box_array,i))
                        f_array_add_pop(bos_array, copied_box)
                        mid = (box.get_top(array.get(box_array,i)) + box.get_bottom(array.get(box_array,i))) / 2
                        box.set_top(array.get(bos_array,0), mid)
                        box.set_bottom(array.get(bos_array,0), mid)
                        box.set_extend( array.get(bos_array,0), extend.none)
                        box.set_right( array.get(bos_array,0), time)
                        box.set_text( array.get(bos_array,0), 'BOS' )
                        box.set_text_valign( array.get(bos_array,0), text.align_bottom)
                        box.set_bgcolor( array.get(bos_array,0), css_bos)
                        box.set_border_color( array.get(bos_array,0), css_bos)
                        box.set_border_style(array.get(bos_array,0), style_bos)
                        box.set_text_color( array.get(bos_array,0), css_textbos)
                        box.set_text_size( array.get(bos_array,0), size.small)
                        box.set_text_halign( array.get(bos_array,0), text.align_center)
                        box.set_text_valign( array.get(bos_array,0), text.align_center)
                    bos_count += 1
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))
                box.delete(array.get(box_barray, i))
                box.delete(array.get(box_sarray, i))
                array.set(buyv_array, i, 0.00) 
                array.set(sellv_array, i, 0.00) 
            else
                if (high >= box_top and low <= box_top) or (high >= box_bottom and low <= box_bottom)
                    in_demand_zone += 1


    [bos_count, choch_count, in_supply_zone, in_demand_zone]



// FUNCTION TO UPDATE VOLUME METRIC ARRAY AND UPDATE BOX TEXTS
f_update_volume_metrics(box_array, boxb_array, boxs_array, buyv_array, sellv_array, box_type) =>
    if use_volumemetrics
        arr_size = array.size(box_array)
        if arr_size > 0
            for i = 0 to arr_size - 1
                top_wick    = high[i] - math.max(close[i], open[i])
                bottom_wick = math.min(close[i], open[i]) - low[i]
                body_size   = math.abs(close[i]-open[i])

                box_top     = box.get_top(array.get(box_array, i))
                box_bottom  = box.get_bottom(array.get(box_array, i))

                current_buyv = array.get(buyv_array, i)
                current_sellv = array.get(sellv_array, i)

                buy_v_calc  =  0.5 * (top_wick + bottom_wick + (open[i] <= close[i] ? 2 * body_size : 0)) / (top_wick + bottom_wick + body_size)
                sell_v_calc =  0.5 * (top_wick + bottom_wick + (open[i] > close[i] ? 2 * body_size : 0)) / (top_wick + bottom_wick + body_size)
                buy_v       = volume[i] * (nz(buy_v_calc) == 0 ? 0.5 : buy_v_calc)
                sell_v      = volume[i] * (nz(sell_v_calc) == 0 ? 0.5 : sell_v_calc)

                inside_zone = (high[i] >= box_top and low[i] <= box_top) or (high[i] >= box_bottom and low[i] <= box_bottom)

                if inside_zone
                    array.set(buyv_array, i, current_buyv + buy_v)
                    array.set(sellv_array, i, current_sellv + sell_v)

                total_vol = (array.get(buyv_array, i)) + (array.get(sellv_array, i))
                all_zone_vol = array.sum(buyv_array) + array.sum(sellv_array)
                vol_pct = total_vol / all_zone_vol *  100

                text_addition = str.tostring(total_vol, format.volume) + "  (" + str.tostring(vol_pct, format.percent) + ")"
                box.set_text(array.get(box_array,i), text_addition)


                // update box sizes
                current_buyleft = box.get_left(array.get(boxb_array, i))
                box.set_right(array.get(boxb_array, i), math.floor(current_buyleft + ((time-current_buyleft) * (array.get(buyv_array, i) / total_vol))) )

                current_sellleft = box.get_left(array.get(boxs_array, i))
                box.set_right(array.get(boxs_array, i), math.floor(current_buyleft + ((time-current_sellleft) * (array.get(sellv_array, i) / total_vol))) )




// FUNCTION MANAGE CURRENT BOXES BY CHANGING ENDPOINT
f_extend_box_endpoint(box_array) =>
    for i = 0 to array.size(box_array) - 1
        box.set_right(array.get(box_array, i), time + (timeframe.in_seconds() * 1000 * indicator_zooming))

  

// function to loop and see if we touch poi
f_inside_zoneboxes(box_array) =>
    inside_count = 0
    for i = 0 to array.size(box_array) - 1
        level_to_test = box.get_bottom(array.get(box_array,i))
        if high > level_to_test and low < level_to_test
            inside_count += 1
            break
    inside_count


// functions for focus mode
f_focusmode_zoneboxes(focus_bool, box_array, boxb_array, boxs_array, buyv_array, sellv_array) =>
    if focus_bool
        temp_size = array.size(box_array)
        if temp_size > 0
            for i = 0 to temp_size - 1
                if box.get_left(array.get(box_array, i)) <= time[focus_mode_len]
                    box.delete(array.get(box_array,i))
                    box.delete(array.get(boxb_array,i))
                    box.delete(array.get(boxs_array,i))
                    array.set(buyv_array, i, 0)
                    array.set(sellv_array, i, 0)

// functions for focus mode
f_focusmode_otherboxes(focus_bool) =>
    if focus_bool
        temp_arr = box.all
        temp_size = array.size(temp_arr)
        if temp_size > 0
            for i = 0 to temp_size - 1
                if box.get_left(array.get(temp_arr, i)) <= time[focus_mode_len] 
                    box.delete(array.get(temp_arr,i))

f_focusmode_eqlineslabels(focus_bool, line_array, label_array) =>
    if focus_bool
        temp_size = array.size(line_array)
        if temp_size > 0
            for i = 0 to temp_size - 1
                if line.get_x1(array.get(line_array, i)) <= time[focus_mode_len]
                    line.delete(array.get(line_array,i))
                    label.delete(array.get(label_array,i))




// CALCULATIONS
atr = ta.atr(50)




// ARRAYS FOR SUPPLY / DEMAND
var current_supply_box = array.new_box(history_of_demand_to_keep, na)
var supply_buyv_box = array.new_box(history_of_demand_to_keep, na) 
var supply_sellv_box = array.new_box(history_of_demand_to_keep, na) 

var current_demand_box = array.new_box(history_of_demand_to_keep, na)
var demand_buyv_box = array.new_box(history_of_demand_to_keep, na) 
var demand_sellv_box = array.new_box(history_of_demand_to_keep, na) 

// ARRAYS FOR SUPPLY / DEMAND POI LABELS
var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)

// ARRAYS FOR VOLUME METRICS
var supply_buyv = array.new_float(history_of_demand_to_keep, 0.00)
var supply_sellv = array.new_float(history_of_demand_to_keep, 0.00)

var demand_buyv = array.new_float(history_of_demand_to_keep, 0.00)
var demand_sellv = array.new_float(history_of_demand_to_keep, 0.00)

// ARRAYS FOR BOS
var arr_supply_bos = array.new_box(10, na)
var arr_demand_bos = array.new_box(10, na)

// ARRAYS FOR CHOCH
var arr_supply_choch = array.new_box(10, na)
var arr_demand_choch = array.new_box(10, na)

// ARRAYS FOR EQUAL HIGH / LOW
var eqh_lines = array.new_line(history_of_demand_to_keep, na)
var eql_lines = array.new_line(history_of_demand_to_keep, na)

var eqh_labels = array.new_label(history_of_demand_to_keep, na)
var eql_labels = array.new_label(history_of_demand_to_keep, na)

var bool new_demand = false
var bool new_supply = false


// supply/demand zones
[sh, sl, psh, psl, csh, csl, hh, lh, ll, hl, trend, last_signal] = f_get_swing_values(swing_length)
// barcolor(not na(sh) ? color.red : not na(sl) ? color.green : na, offset = -10)
if not na(sh)
    // draw supply zone
    new_supply := f_supply_demand(current_supply_box, current_supply_poi, supply_buyv_box, supply_sellv_box, supply_buyv, supply_sellv, 1, atr)
else if not na(sl)
    // draw demand zone
    new_demand := f_supply_demand(current_demand_box, current_demand_poi, demand_buyv_box, demand_sellv_box, demand_buyv, demand_sellv, -1, atr)
else
    new_demand := false
    new_supply := false



// bos and choch
var bool can_choch_supply = true
var bool can_choch_demand = true

[supply_bos, supply_choch, in_supplyz, ignore_in_demandz] =  f_sd_to_bos_choch(current_supply_box, current_supply_poi, supply_buyv_box, supply_sellv_box, supply_buyv, supply_sellv, arr_supply_bos, arr_supply_choch,  can_choch_supply[1], 1)
[demand_bos, demand_choch, ignore_in_supplyz, in_demandz] =  f_sd_to_bos_choch(current_demand_box, current_demand_poi, demand_buyv_box, demand_sellv_box, demand_buyv, demand_sellv, arr_demand_bos, arr_demand_choch, can_choch_demand[1], -1) 
can_choch_supply :=  supply_choch > 0 ? false : lh ? true : can_choch_supply[1]
can_choch_demand := demand_choch > 0 ? false : hl ? true : can_choch_demand[1]



// call focus mode
if barstate.islast
    f_focusmode_zoneboxes(focus_mode, current_supply_box, supply_buyv_box, supply_sellv_box, supply_buyv, supply_sellv)
    f_focusmode_zoneboxes(focus_mode, current_demand_box, demand_buyv_box, demand_sellv_box, demand_buyv, demand_sellv)

    f_focusmode_otherboxes(focus_mode)

    f_focusmode_eqlineslabels(focus_mode, eqh_lines, eqh_labels)
    f_focusmode_eqlineslabels(focus_mode, eql_lines, eql_labels)



// update boxes
f_extend_box_endpoint(current_supply_box)
f_extend_box_endpoint(current_demand_box)


f_update_volume_metrics(current_supply_box, supply_buyv_box, supply_sellv_box, supply_buyv, supply_sellv, 1)
f_update_volume_metrics(current_demand_box, demand_buyv_box, demand_sellv_box, demand_buyv, demand_sellv, -1)


// label.new(bar_index, close, text=str.tostring(array.sum(supply_buyv)))
// label.new(bar_index, high, text=str.tostring(array.size(supply_buyv)))
// label.new(bar_index, low, text=str.tostring(array.size(current_supply_box)))





// function for eqh eql
f_eqh_eql(eq_length, arrh_lines, arrh_labels, arrl_lines, arrl_labels, eq_threshold, eq_bool) =>
    var eq_prev_top = 0.
    var eq_top_x = 0

    var eq_prev_btm = 0.
    var eq_btm_x = 0

    eqh_alert = false 
    eql_alert = false 

    if eq_bool
        eq_top = ta.pivothigh(eq_length, eq_length)
        eq_btm = ta.pivotlow(eq_length, eq_length)

        if eq_top 
            max = math.max(eq_top, eq_prev_top)
            min = math.min(eq_top, eq_prev_top)
            
            if max < min + atr * eq_threshold
                eqh_alert := true
                line.delete( array.get(arrh_lines, array.size(arrh_lines) - 1) )
                f_array_add_pop(arrh_lines, line.new(eq_top_x, eq_prev_top, bar_index-eq_length, eq_top, color = css_eqh, style = style_eqh))

                label.delete( array.get(arrh_labels, array.size(arrh_labels) - 1) )
                f_array_add_pop(arrh_labels, label.new(int(math.avg(bar_index-eq_length, eq_top_x)), eq_top, 'EQH', color = #00000000, textcolor = css_texteqh, style = label.style_label_down, size = size.tiny))
                
            eq_prev_top := eq_top
            eq_top_x := bar_index-eq_length

        if eq_btm 
            max = math.max(eq_btm, eq_prev_btm)
            min = math.min(eq_btm, eq_prev_btm)
            
            if min > max - atr * eq_threshold
                eql_alert := true
                line.delete( array.get(arrh_lines, array.size(arrh_lines) - 1) )
                f_array_add_pop(arrh_lines, line.new(eq_btm_x, eq_prev_btm, bar_index-eq_length, eq_btm, color = css_eql, style = style_eql))

                label.delete( array.get(arrh_labels, array.size(arrh_labels) - 1) )
                f_array_add_pop(arrh_labels, label.new(int(math.avg(bar_index-eq_length, eq_btm_x)), eq_btm, 'EQL', color = #00000000, textcolor = css_texteql, style = label.style_label_up, size = size.tiny))

            eq_prev_btm := eq_btm
            eq_btm_x := bar_index-eq_length

        [eqh_alert, eql_alert]


[eqh_alert5, eql_alert5] = f_eqh_eql(_eq_length5, eqh_lines, eqh_labels, eql_lines, eql_labels, _eq_threshold5, use_eqhl5)
[eqh_alert4, eql_alert4] = f_eqh_eql(_eq_length4, eqh_lines, eqh_labels, eql_lines, eql_labels, _eq_threshold4, use_eqhl4)
[eqh_alert3, eql_alert3] = f_eqh_eql(_eq_length3, eqh_lines, eqh_labels, eql_lines, eql_labels, _eq_threshold3, use_eqhl3)
[eqh_alert2, eql_alert2] = f_eqh_eql(_eq_length2, eqh_lines, eqh_labels, eql_lines, eql_labels, _eq_threshold2, use_eqhl2)
[eqh_alert1, eql_alert1] = f_eqh_eql(_eq_length1, eqh_lines, eqh_labels, eql_lines, eql_labels, _eq_threshold1, use_eqhl1)

var bool new_eqh = false
var bool new_eql = false
new_eqh := (eqh_alert5 or eqh_alert4 or eqh_alert3 or eqh_alert2 or eqh_alert1)
new_eql := (eql_alert5 or eql_alert4 or eql_alert3 or eql_alert2 or eql_alert1)

// volume profile
vp_barlocation  = bar_index + indicator_zooming + vp_location
vp_highest = ta.highest(vp_length)
vp_lowest = ta.lowest(vp_length)

line vp_lines = na
vp_levels = array.new_float(0)
vp_sumv = array.new_float(0)
var vp_a = array.new_line()

if use_vp
    if barstate.isfirst
        for i = 0 to vp_row - 1 by 1
            array.push(vp_a, line.new(na, na, na, na, width=2))

    if barstate.islast
        for i = 0 to vp_row by 1
            array.push(vp_levels, vp_lowest + i / vp_row * (vp_highest - vp_lowest))
        for j = 0 to vp_row - 1 by 1
            vp_sum = 0.
            for k = 0 to vp_length - 1 by 1
                vp_sum := high[k] > array.get(vp_levels, j) and low[k] < array.get(vp_levels, j + 1) ? vp_sum + volume[k] : vp_sum
                vp_sum
            array.push(vp_sumv, vp_sum)
        for j = 0 to vp_row - 1 by 1
            vp_mult = array.get(vp_sumv, j) / array.max(vp_sumv)
            vp_lines := array.get(vp_a, j)
            vp_tempget = array.get(vp_levels, j)
            line.set_xy1(vp_lines, math.min(math.floor(vp_barlocation - (vp_location * vp_mult)), vp_barlocation-1), array.get(vp_levels, j))
            line.set_xy2(vp_lines, vp_barlocation , array.get(vp_levels, j))
            line.set_color(vp_lines,  color.rgb( color.r(vp_color), color.g(vp_color), color.b(vp_color), math.min(100 - vp_mult*100, 80)))
            line.set_width(vp_lines, bar_vp_width)




// ALERTS
var bool is_alert = false
var bool bull_alert = false
var bool bear_alert = false

var string bull_text = na
var string bear_text = na
var string alert_text = na

if barstate.islast

    bullish_bos         = _bullish_bos and supply_bos > 0
    bullish_choch       = _bullish_choch and supply_choch > 0
    bullish_hh          = _bullish_hh and hh and not hh[1]
    bullish_hl          = _bullish_hl and hl and not hl[1]
    bullish_demand_zone = _bullish_demand_zone and new_demand
    bullish_indz        = _bullish_indz and in_demandz > 0 and not new_demand
    bullish_eql         = _bullish_eql and new_eql

    bearish_bos         = _bearish_bos and supply_bos > 0
    bearish_choch       = _bearish_choch and supply_choch > 0
    bearish_ll          = _bearish_ll and ll and not ll[1]
    bearish_lh          = _bearish_lh and lh and not lh[1]
    bearish_supply_zone = _bearish_supply_zone and new_supply
    bearish_insz        = _bearish_insz and in_supplyz > 0 and not new_supply
    bearish_eqh         = _bearish_eqh and new_eqh


    bull_alert := bullish_bos
     or bullish_choch
     or bullish_hh
     or bullish_hl
     or bullish_demand_zone
     or bullish_indz
     or bullish_eql
    bull_text := (bullish_bos ? "BOS, " : " ")
     + (bullish_choch ? "CHoCH, " : " ")
     + (bullish_hh ? "HH, " : " ")
     + (bullish_hl ? "HL, " : " ")
     + (bullish_demand_zone ? "New Demand Zone, " : " ")
     + (bullish_indz ? "In Demand Zone, " : " ")
     + (new_eql ? "New Equal Low, " : " ")


    bear_alert := bearish_bos
     or bearish_choch
     or bearish_ll
     or bearish_lh
     or bearish_supply_zone
     or bearish_insz
     or bearish_eqh
    bear_text := (bearish_bos ? "BOS, " : " ")
     + (bearish_choch ? "CHoCH, " : " ")
     + (bearish_ll ? "LL, " : " ")
     + (bearish_lh ? "LH, " : " ")
     + (bearish_supply_zone ? "New Supply Zone, " : " ")
     + (bearish_insz ? "In Supply Zone, " : " ")
     + (new_eqh ? "New Equal High, " : " ")


    // bgcolor(bullish_indz ? color.green : bearish_insz ? color.red : na)

    alert_text := (bull_alert ? "Bullish: " + bull_text : '') + (bear_alert ? "\n\nBearish: " + bear_text : '')
    if (bull_alert or bear_alert) 
        alert(alert_text, alert.freq_once_per_bar_close)
