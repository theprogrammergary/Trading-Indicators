// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//@version=5
indicator('for_mattmoheeka', format=format.price, precision=2, overlay=false)

//INPUTS
debug_mode = input.bool(false, title = 'Debug Mode', group = 'Other Settings')
time_to_scan = input.session('1220-1221', title = 'Time For Scan', group = 'Other Settings', tooltip = 'Uses EST or NY Market Hours for timezone.')

g1_score = input.int(4, title = 'Score', group = 'Group 1')
g1_symbol1 = input.symbol("AAPL", title = 'Symbol 1', group = 'Group 1')
g1_symbol2 = input.symbol("META", title = 'Symbol 2', group = 'Group 1')
g1_symbol3 = input.symbol("GOOG", title = 'Symbol 3', group = 'Group 1')
g1_symbol4 = input.symbol("AMZN", title = 'Symbol 4', group = 'Group 1')
g1_symbol5 = input.symbol("NFLX", title = 'Symbol 5', group = 'Group 1')
g1_symbol6 = input.symbol("MSFT", title = 'Symbol 6', group = 'Group 1')
g1_symbol7 = input.symbol("AMD", title = 'Symbol 7', group = 'Group 1')

g2_symbol1 = input.symbol("QQQ", title = 'Symbol 1', group = 'Group 2')

g3_symbol1 = input.symbol("SQQQ", title = 'Symbol 1', group = 'Group 3')

//FUNCTION
f_pctchg(symbol) =>

    previous_close = request.security(symbol, 'D', close[1], barmerge.gaps_off, barmerge.lookahead_on)
    current_price = request.security(symbol, '', close)
    pct_change = (current_price - previous_close) / previous_close * 100
    pct_change


//GROUP 1 CALCS
g1_s1_value = f_pctchg(g1_symbol1) > 0 ? 1 : 0
g1_s2_value = f_pctchg(g1_symbol2) > 0 ? 1 : 0
g1_s3_value = f_pctchg(g1_symbol3) > 0 ? 1 : 0
g1_s4_value = f_pctchg(g1_symbol4) > 0 ? 1 : 0
g1_s5_value = f_pctchg(g1_symbol5) > 0 ? 1 : 0
g1_s6_value = f_pctchg(g1_symbol6) > 0 ? 1 : 0
g1_s7_value = f_pctchg(g1_symbol7) > 0 ? 1 : 0

g1_cond = (g1_s1_value + g1_s2_value + g1_s3_value + g1_s4_value + g1_s5_value + g1_s6_value + g1_s7_value) >= g1_score ? 1 : 0 

//GROUP 2 CALCS
g2_s1_value = f_pctchg(g2_symbol1)
g2_cond = g2_s1_value > 0 ? 1 : 0

//GROUP 3 CALCS
g3_s1_value = f_pctchg(g3_symbol1)
g3_cond = g3_s1_value < 0 ? 1 : 0

// PLOT DEBUG
groups_cond = ( (g1_cond + g2_cond + g3_cond) == 3 ) ? 1 : 0
plot(groups_cond, title = 'Groups Value', color = color.red, style = plot.style_circles)
plot( -(g1_cond), title = 'DEBUG Group 1', style = plot.style_circles) // All GROUP 1
plot( -(g2_cond), title = 'DEBUG Group 2', style = plot.style_circles) // All GROUP 2
plot( -(g3_cond), title = 'DEBUG Group 3', style = plot.style_circles) // All GROUP 3

//SCAN - ALERTS
is_time_to_scan = time(timeframe.period, str.format('{0}:1234567', time_to_scan), 'America/New_York')
scan_cond = ( groups_cond == 1 ) and  ( ( debug_mode ) or ( is_time_to_scan ) )
bgcolor(scan_cond ? color.yellow : na)


//TIME BASED ALERT
if is_time_to_scan
    if scan_cond == true
        alert("signal:1", alert.freq_once_per_bar_close)
    else 
        alert("signal:0", alert.freq_once_per_bar_close)
        
else if debug_mode == true
    if groups_cond == true
        alert("signal:1", alert.freq_once_per_bar_close)
    else 
        alert("signal:0", alert.freq_once_per_bar_close)



//BUILD NOTES

// This is 'Group 1'
// f_chgpct(input.symbol('AAPL'))
// f_chgpct(input.symbol('META'))
// f_chgpct(input.symbol('GOOG'))
// f_chgpct(input.symbol('AMZN'))
// f_chgpct(input.symbol('NFLX'))
// f_chgpct(input.symbol('MSFT'))
// f_chgpct(input.symbol('AMD'))

// // This is 'Group 2'
// f_chgpct(input.symbol('QQQ'))

// // This is 'Group 3'
// f_chgpct(input.symbol('SQQQ'))

// =========================================================================

// Context for signals/logic I'm looking to produce //

// I've been using this watchlist manually to produce signals for my own trading algorithms. I just check it in the morning and run things manually
// I was scraping web data, but its incredibly unreliable compared to TV
// I'm looking to check +/- % changes from their previous closes to rank and produce simple binary signals and send an alert that I can pull out of TV via webook so I can
// reformat as json data and throw into my python app

// Breakdown //

// You can see above, I have the symbols in the watchlist broken into different groups
// I need each group to produce a score based on +/- % change from previous close at 9:20AM
// 'Group 1' - If 4 out of 7 or greater has a positive % change, it gets a score of 1, else 0
// 'Group 2' - If positive % change, it gets a score of 1, else 0
// 'Group 3'(inverse) - If positive % change it gets a score of 0, else 1

// These scores get stored and ranked out of 3 since there are 3 groups
// I'm looking for 3/3 or 0/0
// If 3/3 I want the alert to fire '1'
// If 0/0 I want the alert to fire '0'

// As an add-on I would like a 'debug mode' for time so I don't have to test at 9:20AM, I can test the alert at any time of the day to test that it's working











